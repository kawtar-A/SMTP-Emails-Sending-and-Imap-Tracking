# -*- coding: utf-8 -*-
"""Streamlit APP - Newsletter Sender

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sRAlkSJB7VPYPGHoYsVyD88FxKwASwpQ
"""

# newsletter_web_app.py
# Streamlit-based hosted version of your newsletter system

import streamlit as st
import pandas as pd
import uuid
from pathlib import Path
from datetime import datetime
import hashlib
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.utils import formataddr, make_msgid
from email.header import Header
import re, time, os
from pytz import timezone

# === CONFIG ===
TEMPLATE_PATH = Path("newsletter_template.html")
SENDER_EMAIL = st.secrets["SENDER_EMAIL"]
APP_PASSWORD = st.secrets["APP_PASSWORD"]
SPREADSHEET_ID = st.secrets["SPREADSHEET_ID"]
GAS_TRACKING_URL = st.secrets["GAS_TRACKING_URL"]
SERVICE_ACCOUNT_FILE = "config/GoogleAPI.json"
SMTP_SERVER, SMTP_PORT = "smtp.gmail.com", 465
SENDER_NAME = "Victoria Branson"
BCC_EMAIL = "8150892@bcc.hubspot.com"

import gspread
from google.oauth2.service_account import Credentials

def load_articles():
    """Load top 5 articles from Google Sheet tab 'Newsletter Articles-Week1'."""
    scopes = ["https://www.googleapis.com/auth/spreadsheets", "https://www.googleapis.com/auth/drive"]
    creds = Credentials.from_service_account_file(SERVICE_ACCOUNT_FILE, scopes=scopes)
    client = gspread.authorize(creds)
    sheet = client.open_by_key(SPREADSHEET_ID)
    ws = sheet.worksheet("Newsletter Articles-Week1")  # <- change if your tab name differs
    records = ws.get_all_records()

    # Expecting columns: Title, Subtitle, Img, Url
    articles = []
    for r in records[:5]:
        articles.append({
            "title": r.get("Title", ""),
            "subtitle": r.get("Subtitle", ""),
            "img": r.get("Img", "https://via.placeholder.com/120"),
            "url": r.get("Url", "#")
        })
    return articles

# === HELPERS ===
def email_hash(addr): return hashlib.sha256(addr.lower().encode()).hexdigest()[:16]
def truncate(s, n=140): return (s or "").strip()[:max(0, n)].rstrip("‚Ä¶") + ("‚Ä¶" if len(s) > n else "")
def strip_html_to_text(h): return re.sub(r"<.*?>", "", h).strip()
def build_open_pixel(b, s, nid, sid, mid, e):
    return f'<img src="{GAS_TRACKING_URL}?t=open&b={b}&s={s}&nid={nid}&sid={sid}&mid={mid}&e={e}" width="1" height="1" style="display:none;">'
def build_tracking_link(t, b, s, nid, sid, mid, e, to=""):
    return f"{GAS_TRACKING_URL}?t={t}&b={b}&s={s}&nid={nid}&sid={sid}&mid={mid}&e={e}&to={to}"

# === STREAMLIT UI ===
st.title("üì¨ Newsletter Sender App")
st.markdown("Upload contact CSV, pick a vertical, preview newsletter, then send.")

with st.sidebar:
    vertical_input = st.text_input("Vertical (e.g. Forestry)")
    batch_name = st.text_input("Batch Name", value="Newsletter_Batch")
    step = st.number_input("Sequence Step", min_value=1, value=1)

contact_file = st.file_uploader("Upload contacts CSV", type="csv")

# === Load Template ===
if not TEMPLATE_PATH.exists():
    st.error("Template file not found.")
    st.stop()
html_template = TEMPLATE_PATH.read_text(encoding="utf-8")

# === Actions ===
if vertical_input and contact_file:
    df = pd.read_csv(contact_file)
    st.success(f"Loaded {len(df)} contacts")

    # --- Buttons ---
    preview_btn = st.button("üîç Preview Newsletter")
    send_btn = st.button("‚úâÔ∏è Send Emails")

    if preview_btn:
        articles = load_articles()  # from GSheet function
        preview_html = html_template.replace("{{vertical_name}}", vertical_input.title())
        for i, art in enumerate(articles, 1):
            preview_html = preview_html.replace(f"{{{{news{i}_title}}}}", art["title"])
            preview_html = preview_html.replace(f"{{{{news{i}_subtitle}}}}", truncate(art["subtitle"]))
            preview_html = preview_html.replace(f"{{{{news{i}_img}}}}", art["img"])
            preview_html = preview_html.replace(f"{{{{news{i}_url}}}}", art["url"])

        preview_html = preview_html.replace("{{prefs_link}}", "#")
        preview_html = preview_html.replace("{{unsub_link}}", "#")

        st.markdown("### Preview")
        st.components.v1.html(preview_html, height=800, scrolling=True)

    if send_btn:
        articles = load_articles()
        server = smtplib.SMTP_SSL(SMTP_SERVER, SMTP_PORT)
        server.login(SENDER_EMAIL, APP_PASSWORD)
        with server:
            for i, row in df.iterrows():
                email = row.get("Email")
                if not email or "@" not in email:
                    continue

                mid = make_msgid()
                ehash = email_hash(email)

                # Build personalized HTML
                html = html_template.replace("{{vertical_name}}", vertical_input.title())
                for j, art in enumerate(articles, 1):
                    html = html.replace(f"{{{{news{j}_title}}}}", art["title"])
                    html = html.replace(f"{{{{news{j}_subtitle}}}}", truncate(art["subtitle"]))
                    html = html.replace(f"{{{{news{j}_img}}}}", art["img"])
                    html = html.replace(f"{{{{news{j}_url}}}}", art["url"])
                html = html.replace("{{prefs_link}}", build_tracking_link("prefs", batch_name, step, "nid", ehash, mid.strip("<>"), ehash))
                html = html.replace("{{unsub_link}}", build_tracking_link("unsubscribe", batch_name, step, "nid", ehash, mid.strip("<>"), ehash))
                html = html.replace("</body>", f"{build_open_pixel(batch_name, step, 'nid', ehash, mid.strip('<>'), ehash)}</body>")

                plain = strip_html_to_text(html)
                subject = f"Top 5 {vertical_input} Stories"

                msg = MIMEMultipart("alternative")
                msg["From"] = formataddr((SENDER_NAME, SENDER_EMAIL))
                msg["To"] = email
                msg["Bcc"] = BCC_EMAIL
                msg["Subject"] = Header(subject, "utf-8")
                msg["Message-Id"] = mid
                msg.attach(MIMEText(plain, "plain", "utf-8"))
                msg.attach(MIMEText(html, "html", "utf-8"))

                try:
                    server.sendmail(SENDER_EMAIL, [email, BCC_EMAIL], msg.as_bytes())
                    st.success(f"‚úÖ Sent: {email}")
                except Exception as e:
                    st.error(f"‚ùå Failed: {email} ‚Üí {e}")

                time.sleep(0.3)


